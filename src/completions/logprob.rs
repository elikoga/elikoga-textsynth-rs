//! Provides logprob api

use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;
use thiserror::Error;

use crate::TextSynthClient;

use super::Engine;

/// Struct for a logprob request
#[skip_serializing_none]
#[derive(Serialize, Builder)]
#[builder(setter(into))]
#[builder(build_fn(validate = "Self::validate"))]
pub struct Request {
    /// If empty string, the context is set to the End-Of-Text token.
    context: String,
    /// Must be a non empty string.
    continuation: String,
}

impl RequestBuilder {
    fn validate(&self) -> Result<(), String> {
        // n must be between 1 and 16
        match &self.continuation {
            Some(continuation) if continuation.is_empty() => {
                return Err("Continuation must not be empty".to_string());
            }
            _ => {}
        }
        Ok(())
    }
}

/// Struct for a logprob answer
#[derive(Deserialize, Debug)]
pub struct Response {
    /// Logarithm of the probability of generation of continuation preceeded by
    /// context. It corresponds to the sum of the logarithms of the
    /// probabilities of the tokens of continuation. It is always <= 0.
    pub logprob: f64,
    /// Number of tokens in continuation.
    pub num_tokens: u32,
    /// true if continuation would be generated by greedy sampling from
    /// continuation.
    pub is_greedy: bool,
    /// Indicate the total number of input tokens. It is useful to estimate the
    /// number of compute resources used by the request.
    pub input_tokens: u32,
}

#[derive(Error, Debug)]
/// Error for a completion answer
pub enum Error {
    /// Serde error
    #[error("Serde error: {0}")]
    SerdeError(#[from] serde_json::Error),
    /// Error from Reqwest
    #[error("Reqwest error: {0}")]
    RequestError(#[from] reqwest::Error),
}

impl TextSynthClient {
    /// Perform a completion request
    pub async fn logprob(&self, engine: &Engine, request: &Request) -> Result<Response, Error> {
        let request_json = serde_json::to_string(&request)?;
        let url = format!("{}/engines/{}/logprob", self.base_url, engine);
        let response = self.client.post(&url).body(request_json).send().await?;
        // println!("got response {:?}", response.text().await);
        response.json().await.map_err(|e| e.into())
    }
}
